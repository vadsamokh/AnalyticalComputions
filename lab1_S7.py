import numpy as np

#функция перевода числа в двоичную систему счисления
def binary(a, arr):
        temp = a
        for i in range(len(arr)):
                arr[len(arr)-1-i] = temp % 2
                temp = temp // 2

#####################################   ФУНКЦИЯ S7   ####################################

#инициализация
x = np.zeros(7, dtype=int)
p = np.zeros(7, dtype=int)
y = np.zeros((128, 7), dtype=int)

#Формируем вектора значений разрядных функций y0,...,y6
for i in range(128):
        binary(i, x)
        y[i, 0] = (x[1]*x[3] + x[4] + x[0]*x[1]*x[4] + x[5] + x[2]*x[5] + x[3]*x[4]*x[5] + x[6] + x[0]*x[6] + x[1]*x[6] + x[3]*x[6] + x[2]*x[4]*x[6] + x[1]*x[5]*x[6] + x[4]*x[5]*x[6]) % 2
        y[i, 1] = (x[0]*x[1] + x[0]*x[4] + x[2]*x[4] + x[5] + x[1]*x[2]*x[5] + x[0]*x[3]*x[5] + x[6] + x[0]*x[2]*x[6] + x[3]*x[6] + x[4]*x[5]*x[6] + 1) % 2
        y[i, 2] = (x[0] + x[0]*x[3] + x[2]*x[3] + x[1]*x[2]*x[4] + x[0]*x[3]*x[4] + x[1]*x[5] + x[0]*x[2]*x[5] + x[0]*x[6] + x[0]*x[1]*x[6] + x[2]*x[6] + x[4]*x[6] + 1) % 2
        y[i, 3] = (x[1] + x[0]*x[1]*x[2] + x[1]*x[4] + x[3]*x[4] + x[0]*x[5] + x[0]*x[1]*x[5] + x[2]*x[3]*x[5] + x[1]*x[4]*x[5] + x[2]*x[6] + x[1]*x[3]*x[6]) % 2
        y[i, 4] = (x[0]*x[2] + x[3] + x[1]*x[3] + x[1]*x[4] + x[0]*x[1]*x[4] + x[2]*x[3]*x[4] + x[0]*x[5] + x[1]*x[3]*x[5] + x[0]*x[4]*x[5] + x[1]*x[6] + x[3]*x[6] + x[0]*x[3]*x[6] + x[5]*x[6] + 1) % 2
        y[i, 5] = (x[2] + x[0]*x[2] + x[0]*x[3] + x[1]*x[2]*x[3] + x[0]*x[2]*x[4] + x[0]*x[5] + x[2]*x[5] + x[4]*x[5] + x[1]*x[6] + x[1]*x[2]*x[6] + x[0]*x[3]*x[6] + x[3]*x[4]*x[6] + x[2]*x[5]*x[6] + 1) % 2
        y[i, 6] = (x[1]*x[2] + x[0]*x[1]*x[3] + x[0]*x[4] + x[1]*x[5] + x[3]*x[5] + x[6] + x[0]*x[1]*x[6] + x[2]*x[3]*x[6] + x[1]*x[4]*x[6] + x[0]*x[5]*x[6]) % 2
        #и заодно считаем веса этих функций
        for j in range(7):
                p[j] += y[i, j]

#выводим на экран веса разрядных функций
for i in range(7):
        print('P(y', i ,') = ', p[i], sep = '')


#функция создания матрицы Адамара-Сильвестра
def as_matrix(n):
        W = np.array([[1, 1], [1, -1]])
        for i in range(n-1):
                W = np.bmat([[W, W], [W, -W]])
        return W

#считаем коэффициенты Фурье и выводим их на экран
W128 = as_matrix(7)
print("Коэффициенты Фурье:")
FS7 = W128.dot(y)
print(FS7)

#вероятности совпадения разрядной функции с линейной для коэффициентов Фурье
PFS7 = np.zeros((128, 7), dtype=float)
PFS7 += 0.5
print('Вероятности совпадения разрядной функции с линейной для коэффициентов Фурье:')
PFS7 = PFS7 - (FS7 / 128)
print(PFS7)

#счтаем коэффициенты Адамара-Уолша и выводим их на экран
ye = np.zeros((128, 7), dtype=int)
ye += 1
ye -= 2 * y
print("Коэффициенты Адамара-Уолша:")
AWS7 = W128.dot(ye)
print(AWS7)

#вероятности совпадения разрядной функции с линейной для коэффициентов Адамара-Уолша
PAWS7 = np.zeros((128, 7), dtype=float)
PAWS7 += 0.5
print('Вероятности совпадения разрядной функции с линейной для коэффициентов Адамара-Уолша:')
PAWS7 = PAWS7 + (AWS7 / 256)
print(PAWS7)

#действительные многочлены
#функция создания матрицы B
def B_matrix(n):
        B = np.array([[1, 0], [-1, 1]])
        for i in range(n-1):
                B = np.bmat([[B, B-B], [-B, B]]) #не знаю, как тут обозначить матрицу из 0, поэтому написал B-B :)
        return B

#коэффициенты действительного многочлена
B128 = B_matrix(7)
print('Коэффициенты действительного многочлена:')
Z = B128.dot(y)
print(Z)
