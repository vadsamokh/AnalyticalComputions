import numpy as np

#функция перевода числа в двоичную систему счисления
def binary(a, arr):
        temp = a
        for i in range(len(arr)):
                arr[len(arr)-1-i] = temp % 2
                temp = temp // 2

#####################################   ФУНКЦИЯ S9   ####################################

#инициализация
x = np.zeros(9, dtype=int)
p = np.zeros(9, dtype=int)
y = np.zeros((512, 9), dtype=int)

#Формируем вектора значений разрядных функций y0,...,y8
for i in range(512):
        binary(i, x)
        y[i, 0] = (x[0]*x[2] + x[3] + x[2]*x[5] + x[5]*x[6] + x[0]*x[7] + x[1]*x[7] + x[2]*x[7] + x[4]*x[8] + x[5]*x[8] + x[7]*x[8] + 1) % 2
        y[i, 1] = (x[1] + x[0]*x[1] * x[2]*x[3] + x[0]*x[4] + x[1]*x[4] + x[0]*x[5] + x[3]*x[5] + x[6] + x[1]*x[7] + x[2]*x[7] + x[5]*x[8] + 1) % 2
        y[i, 2] = (x[1] + x[0]*x[3] + x[3]*x[4] + x[0]*x[5] + x[2]*x[6] + x[3]*x[6] + x[5]*x[6] + x[4]*x[7] + x[5]*x[7] + x[6]*x[7] + x[8] + x[0]*x[8] + 1) % 2
        y[i, 3] = (x[0] + x[1]*x[2] + x[0]*x[3] + x[2]*x[4] + x[5] + x[0]*x[6] + x[1]*x[6] + x[4]*x[7] + x[0]*x[8] + x[1]*x[8] + x[7]*x[8]) % 2
        y[i, 4] = (x[0]*x[1] + x[1]*x[3] + x[4] + x[0]*x[5] + x[3]*x[6] + x[0]*x[7] + x[6]*x[7] + x[1]*x[8] + x[2]*x[8] + x[3]*x[8]) % 2
        y[i, 5] = (x[2] + x[1]*x[4] + x[4]*x[5] + x[0]*x[6] + x[1]*x[6] + x[3]*x[7] + x[4]*x[7] + x[6]*x[7] + x[5]*x[8] + x[6]*x[8] + x[7]*x[8] + 1) % 2
        y[i, 6] = (x[0] + x[2]*x[3] + x[1]*x[5] + x[2]*x[5] + x[4]*x[5] + x[3]*x[6] + x[4]*x[6] + x[5]*x[6] + x[7] + x[1]*x[8] + x[3]*x[8] + x[5]*x[8] + x[7]*x[8]) % 2
        y[i, 7] = (x[0]*x[1] + x[0]*x[2] + x[1]*x[2] + x[3] + x[0]*x[3] + x[2]*x[3] + x[4]*x[5] + x[2]*x[6] + x[3]*x[6] + x[2]*x[7] + x[5]*x[7] + x[8] + 1) % 2
        y[i, 8] = (x[0]*x[1] + x[2] + x[1]*x[2] + x[3]*x[4] + x[1]*x[5] + x[2]*x[5] + x[1]*x[6] + x[4]*x[6] + x[7] + x[2]*x[8] + x[3]*x[8]) % 2
        #и заодно считаем веса этих функций
        for j in range(9):
                p[j] += y[i, j]

#выводим на экран веса разрядных функций
for i in range(9):
        print('P(y', i ,') = ', p[i], sep = '')


#функция создания матрицы Адамара-Сильвестра
def as_matrix(n):
        W = np.array([[1, 1], [1, -1]])
        for i in range(n-1):
                W = np.bmat([[W, W], [W, -W]])
        return W

#считаем коэффициенты Фурье и выводим их на экран
W512 = as_matrix(9)
print("Коэффициенты Фурье:")
FS9 = W512.dot(y)
print(FS9)

#вероятности совпадения разрядной функции с линейной для коэффициентов Фурье
PFS9 = np.zeros((512, 9), dtype=float)
PFS9 += 0.5
print('Вероятности совпадения разрядной функции с линейной для коэффициентов Фурье:')
PFS9 = PFS9 - (FS9 / 512)
print(PFS9)

#счтаем коэффициенты Адамара-Уолша и выводим их на экран
ye = np.zeros((512, 9), dtype=int)
ye += 1
ye -= 2 * y
print("Коэффициенты Адамара-Уолша:")
AWS9 = W512.dot(ye)
print(AWS9)

#вероятности совпадения разрядной функции с линейной для коэффициентов Адамара-Уолша
PAWS9 = np.zeros((512, 9), dtype=float)
PAWS9 += 0.5
print('Вероятности совпадения разрядной функции с линейной для коэффициентов Адамара-Уолша:')
PAWS9 = PAWS9 + (AWS9 / 1024)
print(PAWS9)

#действительные многочлены
#функция создания матрицы B
def B_matrix(n):
        B = np.array([[1, 0], [-1, 1]])
        for i in range(n-1):
                B = np.bmat([[B, B-B], [-B, B]]) #не знаю, как тут обозначить матрицу из 0, поэтому написал B-B :)
        return B

#коэффициенты действительного многочлена
B512 = B_matrix(9)
print('Коэффициенты действительного многочлена:')
Z = B512.dot(y)
print(Z)
